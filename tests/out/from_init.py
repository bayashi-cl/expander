import os
import sys
from importlib.machinery import ModuleSpec, SourceFileLoader


class BundleImporter(SourceFileLoader):
    """Importer that supports importing from strings in code.

    This class is automatically generated by expander.
    """

    module_ispkg = dict()
    module_code = dict()

    @classmethod
    def add_module(cls, fullname, is_package, code):
        cls.module_ispkg[fullname] = is_package
        cls.module_code[cls.get_filename(fullname)] = bytes(code, encoding="utf-8")

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        if fullname in cls.module_ispkg:
            return ModuleSpec(
                fullname,
                cls(fullname, ""),
                is_package=cls.module_ispkg[fullname],
            )
        else:
            return None

    @classmethod
    def get_filename(cls, fullname):
        return fullname.replace(".", "_") + ".py"

    def get_data(self, path):
        try:
            return super().get_data(path)
        except OSError:
            try:
                return self.module_code[path]
            except KeyError:
                raise OSError

    def path_stats(self, path):
        return {"mtime": os.stat(__file__).st_mtime, "size": None}


BundleImporter.add_module(
    fullname="testlib_a",
    is_package=True,
    code="""\
__version__ = "1.0.0"
""",
)

BundleImporter.add_module(
    fullname="testlib_a.sublib_b",
    is_package=True,
    code="""\
from .sub_ba import print_name_sublib_sub_ba
""",
)

BundleImporter.add_module(
    fullname="testlib_a.sublib_b.sub_ba",
    is_package=False,
    code="""\
def print_name_sublib_sub_ba():
    print(__name__)
""",
)

sys.meta_path.append(BundleImporter)

from testlib_a.sublib_b import print_name_sublib_sub_ba

print_name_sublib_sub_ba()
