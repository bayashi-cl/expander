import ast
import importlib.metadata
from functools import lru_cache
from logging import getLogger
from modulefinder import ModuleFinder
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

from pkg_resources import Environment

logger = getLogger(__name__)

CODE_BUNDLE_IMPORTER = '''\
import os
import sys
from importlib.machinery import ModuleSpec, SourceFileLoader


class BundleImporter(SourceFileLoader):
    """Importer that supports importing from strings in code.

    This class is automatically generated by expander.
    """

    module_ispkg = dict()
    module_code = dict()

    @classmethod
    def add_module(cls, fullname, is_package, code):
        cls.module_ispkg[fullname] = is_package
        cls.module_code[cls.get_filename(fullname)] = bytes(code, encoding="utf-8")

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        if fullname in cls.module_ispkg:
            return ModuleSpec(
                fullname,
                cls(fullname, ""),
                is_package=cls.module_ispkg[fullname],
            )
        else:
            return None

    @classmethod
    def get_filename(cls, fullname):
        return fullname.replace(".", "_") + ".py"

    def get_data(self, path):
        try:
            return self.module_code[path]
        except KeyError:
            with open(path, "rb") as file:
                return file.read()

    def path_stats(self, path):
        return {"mtime": os.stat(__file__).st_mtime, "size": None}

'''

ATCODER_MODULES = [
    "Cython",
    "cython",
    "decorator",
    "easy_install",
    "joblib",
    "llvmlite",
    "networkx",
    "numba",
    "numpy",
    "pkg_resources",
    "pyximport",
    "scipy",
    "setuptools",
    "sklearn",
]


class FutureImportFinder(ast.NodeVisitor):
    def __init__(self) -> None:
        self.last_future = 0

    def visit_ImportFrom(self, node: ast.ImportFrom) -> Any:
        if node.module == "__future__":
            if node.end_lineno is None:
                end = node.lineno
            else:
                end = node.end_lineno

            self.last_future = max(self.last_future, end)

    @classmethod
    def search_insert_point(cls, code: str) -> int:
        tree = ast.parse(code)
        visitor = cls()
        visitor.visit(tree)
        return visitor.last_future


@lru_cache(maxsize=1)
def get_package_info() -> Tuple[Dict[str, str], Dict[str, Optional[str]]]:
    module_to_pkg_name: Dict[str, str] = dict()
    pkg_license: Dict[str, Optional[str]] = dict()
    for pkg_name, env in Environment()._distmap.items():  # type: ignore
        for dist in env:
            try:
                pkg_license[pkg_name] = dist._provider.get_metadata("LICENSE")
            except Exception:
                pkg_license[pkg_name] = None
            try:
                for top in dist._provider.get_metadata_lines("top_level.txt"):
                    module_to_pkg_name[top] = pkg_name
            except Exception:
                pass
    return module_to_pkg_name, pkg_license


def make_metadata(package: str) -> Optional[str]:
    module_to_pkg_name, pkg_license = get_package_info()
    res = []
    if package in module_to_pkg_name:
        pkg_name = module_to_pkg_name[package]
        meta = importlib.metadata.metadata(pkg_name)
        res.append(f'# {meta["Name"]}\n')
        for field in ["Version", "Author", "Home-page", "License"]:
            if field in meta:
                res.append(f"#   {field:<9s}: {meta[field]}\n")
        if meta["License"] not in {"CC0"}:
            license_text = pkg_license[pkg_name]
            if license_text is not None:
                res.append("#\n")
                for line in license_text.splitlines():
                    res.append(f"#   {line}\n")
        return "".join(res)
    else:
        return None


def importer_expand(source: Path, expand_module: List[str]) -> str:
    """Expand modules using importlib.

    Args:
        source (Path): source to expand
        expand (List[str]): List of expand module names.

    Returns:
        str: expanded code

    Note:
        This module is intended to be used in competition programming.

    """
    finder = ModuleFinder(excludes=ATCODER_MODULES)
    finder.run_script(str(source))

    result: List[str] = []
    bundled: Set[str] = set()
    for module in finder.modules.values():
        name: str = module.__name__  # type: ignore
        file: str = module.__file__  # type: ignore
        is_package = module.__path__ is not None  # type: ignore
        top_package = name.split(".")[0]

        if top_package in expand_module:
            bundled.add(top_package)
            logger.info(f"Load `{name}` from {file}")
            if not result:
                result.append(CODE_BUNDLE_IMPORTER)

            module_code = Path(file).read_text()
            module_code = module_code.replace("\\", "\\\\")
            module_code = module_code.replace('"""', '\\"""')

            add_modue_code = f'''\
BundleImporter.add_module(
    fullname="{name}",
    is_package={is_package},
    code="""\\
{module_code}""",
)
'''
            result.append(add_modue_code)

    if result:
        result.append("sys.meta_path.append(BundleImporter)\n\n")

    code = source.read_text()
    insert_point = FutureImportFinder.search_insert_point(code)
    code_lines = code.splitlines(keepends=True)
    code_lines.insert(insert_point, "\n".join(result))

    infomations: List[str] = []
    if bundled:
        for top_package in bundled:
            info = make_metadata(top_package)
            if info is not None:
                if not infomations:
                    code_lines.append("\n\n# package infomations\n")
                    code_lines.append("# " + "-" * 77 + "\n")
                code_lines.append(info)
                code_lines.append("# " + "-" * 77 + "\n")

    return "".join(code_lines + infomations)
