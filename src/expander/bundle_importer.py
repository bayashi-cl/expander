"""Bundled code generator

Note:
    Generate a `Importer` that allows import from string objects in the
    source, and register the modules to be bundled in it.

    BundledImporter inherits importlib.machinery.SourceFileLoader which
    is used when importing normal modules. It provides source code from
    its own dictionary instead of the file system.

    see: https://docs.python.org/3/reference/import.html
"""

from __future__ import annotations

import ast
import importlib.metadata
import sys
from logging import getLogger
from modulefinder import ModuleFinder
from pathlib import Path

from .license_string import get_license_string

logger = getLogger(__name__)

BUNDLE_IMPORTER_CODE = '''\
import os
import sys
from importlib.machinery import ModuleSpec, SourceFileLoader


class BundleImporter(SourceFileLoader):
    """Importer that supports importing from strings in code.

    This class is automatically generated by expander.
    """

    module_ispkg = dict()
    module_code = dict()

    @classmethod
    def add_module(cls, fullname, is_package, code):
        cls.module_ispkg[fullname] = is_package
        cls.module_code[cls.get_filename(fullname)] = bytes(code, encoding="utf-8")

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        if fullname in cls.module_ispkg:
            return ModuleSpec(
                fullname,
                cls(fullname, ""),
                is_package=cls.module_ispkg[fullname],
            )
        else:
            return None

    @classmethod
    def get_filename(cls, fullname):
        return fullname.replace(".", "_") + ".py"

    def get_data(self, path):
        try:
            return super().get_data(path)
        except OSError:
            try:
                return self.module_code[path]
            except KeyError:
                raise OSError

    def path_stats(self, path):
        return {"mtime": os.stat(__file__).st_mtime, "size": None}

'''

# These modules cannot be analyzed by modulefinder due to an error.
EXCLUDE_MODULES = ["networkx", "numba", "sklearn"]


class FutureImportFinder(ast.NodeVisitor):
    """Find the bottom of future statement.

    Note:
        A future statement must appear near the top of the module.
        see: https://docs.python.org/3/reference/simple_stmts.html#future
    """

    def __init__(self) -> None:
        self.last_future = 0

    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:  # noqa: N802
        if node.module == "__future__":
            end = node.lineno if node.end_lineno is None else node.end_lineno
            self.last_future = max(self.last_future, end)


def search_insert_point(code: str) -> int:
    tree = ast.parse(code)

    # future statement
    visitor = FutureImportFinder()
    visitor.visit(tree)

    # docstring
    docstring = 0
    if tree.body:
        top_node = tree.body[0]
        if (
            isinstance(top_node, ast.Expr)
            and isinstance(top_node.value, ast.Constant)
            and isinstance(top_node.value.value, str)
        ):
            docstring = top_node.lineno if top_node.end_lineno is None else top_node.end_lineno

    # top comment
    comment = 0
    code_lines = code.splitlines()
    n_lines = len(code_lines)
    while comment < n_lines and code_lines[comment].rstrip().startswith("#"):
        comment += 1

    return max(visitor.last_future, docstring, comment)


def make_info(bundled_modules: set[str]) -> str | None:
    """Get package metadatas.

    Note:
        Some modules have a different module name than the package name
        (e.g. scikit-learn <-> sklearn). The package name is needed to
        get the package metadata, but usually you can't get the package
        name from the module name. Therefore, check the module name
        included in all installed packages.
    """
    pkgs = set()
    for dist in importlib.metadata.distributions():
        tops = dist.read_text("top_level.txt")
        if tops is None:
            continue
        for top in tops.splitlines():
            if top in bundled_modules:
                pkgs.add(dist.metadata["Name"])

    if not pkgs:
        return None

    sep = "# " + "-" * 77 + "\n"
    result = ["\n# package informations\n", sep]
    for pkg in sorted(pkgs):
        dist = importlib.metadata.distribution(pkg)
        result.append(f'# {dist.metadata["Name"]}\n')
        for field in ["Version", "Author", "Home-page", "License"]:
            if field in dist.metadata:
                result.append(f"#   {field:<9s}: {dist.metadata[field]}\n")  # noqa: PERF401

        result += get_license_string(dist)
        result.append(sep)

    return "".join(result)


def importer_expand(source: Path, expand_module: list[str]) -> str:
    """Expand modules using importlib.

    Args:
        source (Path): source to expand
        expand (List[str]): List of expand module names.

    Returns:
        str: expanded code

    Note:
        This module is intended to be used in competition programming.
    """
    finder = ModuleFinder(excludes=EXCLUDE_MODULES)
    finder.run_script(str(source))

    result: list[str] = []
    bundled: set[str] = set()
    for name, module in finder.modules.items():
        if not hasattr(module, "__file__") or not hasattr(module, "__path__"):
            raise ValueError
        file: str = module.__file__
        is_package = module.__path__ is not None
        top_package = name.split(".")[0]

        if file is None:
            # built-in module
            continue

        if top_package in expand_module:
            if not file.endswith(".py"):
                logger.error("Cannot bundle extention module.")
                sys.exit(1)

            bundled.add(top_package)
            logger.info("Load `%s` from %s", name, file)
            if not result:
                result.append(BUNDLE_IMPORTER_CODE)

            module_code = Path(file).read_text()
            module_code = module_code.replace("\\", "\\\\")
            module_code = module_code.replace('"""', '\\"""')
            result.append(
                "BundleImporter.add_module(\n"
                f'    fullname="{name}",\n'
                f"    is_package={is_package},\n"
                '    code="""\\\n'
                f'{module_code}""",\n'
                ")\n",
            )

    if result:
        result.append("sys.meta_path.append(BundleImporter)\n\n")

    code = source.read_text()
    insert_point = search_insert_point(code)
    code_lines = code.splitlines(keepends=True)
    if insert_point == 0:
        code_lines.insert(insert_point, "\n".join(result))
    else:
        code_lines.insert(insert_point, "\n" + "\n".join(result))

    info = make_info(bundled)
    if info is not None:
        code_lines.append(info)

    return "".join(code_lines)
