"""Bundled code generator

Note:
    Generate a `Importer` that allows import from string objects in the
    source, and register the modules to be bundled in it.

    BundledImporter inherits importlib.machinery.SourceFileLoader which
    is used when importing normal modules. It provides source code from
    its own dictionary instead of the file system.

    see: https://docs.python.org/3/reference/import.html
"""

import ast
import importlib.metadata
import sys
from functools import lru_cache
from logging import getLogger
from modulefinder import ModuleFinder
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple

from pkg_resources import Environment

logger = getLogger(__name__)

BUNDLE_IMPORTER_CODE = '''\
import os
import sys
from importlib.machinery import ModuleSpec, SourceFileLoader


class BundleImporter(SourceFileLoader):
    """Importer that supports importing from strings in code.

    This class is automatically generated by expander.
    """

    module_ispkg = dict()
    module_code = dict()

    @classmethod
    def add_module(cls, fullname, is_package, code):
        cls.module_ispkg[fullname] = is_package
        cls.module_code[cls.get_filename(fullname)] = bytes(code, encoding="utf-8")

    @classmethod
    def find_spec(cls, fullname, path=None, target=None):
        if fullname in cls.module_ispkg:
            return ModuleSpec(
                fullname,
                cls(fullname, ""),
                is_package=cls.module_ispkg[fullname],
            )
        else:
            return None

    @classmethod
    def get_filename(cls, fullname):
        return fullname.replace(".", "_") + ".py"

    def get_data(self, path):
        try:
            return super().get_data(path)
        except OSError:
            try:
                return self.module_code[path]
            except KeyError:
                raise OSError

    def path_stats(self, path):
        return {"mtime": os.stat(__file__).st_mtime, "size": None}

'''

# These modules cannot be analyzed by modulefinder due to an error.
EXCLUDE_MODULES = ["networkx", "numba", "sklearn"]


class FutureImportFinder(ast.NodeVisitor):
    """Find the bottom of future statement.

    Note:
        A future statement must appear near the top of the module.
        see: https://docs.python.org/3/reference/simple_stmts.html#future
    """

    def __init__(self) -> None:
        self.last_future = 0

    def visit_ImportFrom(self, node: ast.ImportFrom) -> Any:
        if node.module == "__future__":
            if node.end_lineno is None:
                end = node.lineno
            else:
                end = node.end_lineno

            self.last_future = max(self.last_future, end)


def search_insert_point(code: str) -> int:
    tree = ast.parse(code)

    # future statement
    visitor = FutureImportFinder()
    visitor.visit(tree)

    # docstring
    docstring = 0
    if tree.body:
        top_node = tree.body[0]
        if (
            isinstance(top_node, ast.Expr)
            and isinstance(top_node.value, ast.Constant)
            and isinstance(top_node.value.value, str)
        ):
            if top_node.end_lineno is None:
                docstring = top_node.lineno
            else:
                docstring = top_node.end_lineno

    # top comment
    comment = 0
    code_lines = code.splitlines()
    n_lines = len(code_lines)
    while comment < n_lines and code_lines[comment].rstrip().startswith("#"):
        comment += 1

    return max(visitor.last_future, docstring, comment)


@lru_cache(maxsize=1)
def get_package_info() -> Tuple[Dict[str, str], Dict[str, Optional[str]]]:
    """Get the relationship between module and package.

    Note:
        Some modules have a different module name than the package name
        (e.g. scikit-learn <-> sklearn). The package name is needed to
        get the package metadata, but usually you can't get the package
        name from the module name. Therefore, check the module name
        included in all installed packages.
    """
    module_to_pkg_name: Dict[str, str] = dict()
    pkg_license: Dict[str, Optional[str]] = dict()
    for pkg_name, env in Environment()._distmap.items():  # type: ignore
        for dist in env:
            try:
                pkg_license[pkg_name] = dist._provider.get_metadata("LICENSE")
            except Exception:
                pkg_license[pkg_name] = None
            try:
                for top in dist._provider.get_metadata_lines("top_level.txt"):
                    module_to_pkg_name[top] = pkg_name
            except Exception:
                pass
    return module_to_pkg_name, pkg_license


def make_metadata(package: str) -> Optional[str]:
    module_to_pkg_name, pkg_license = get_package_info()
    res = []
    if package in module_to_pkg_name:
        pkg_name = module_to_pkg_name[package]
        meta = importlib.metadata.metadata(pkg_name)
        res.append(f'# {meta["Name"]}\n')
        for field in ["Version", "Author", "Home-page", "License"]:
            if field in meta:
                res.append(f"#   {field:<9s}: {meta[field]}\n")
        if meta["License"] not in {"CC0"}:
            license_text = pkg_license[pkg_name]
            if license_text is not None:
                res.append("#\n")
                for line in license_text.splitlines():
                    res.append(f"#   {line}\n")
        return "".join(res)
    else:
        return None


def importer_expand(source: Path, expand_module: List[str]) -> str:
    """Expand modules using importlib.

    Args:
        source (Path): source to expand
        expand (List[str]): List of expand module names.

    Returns:
        str: expanded code

    Note:
        This module is intended to be used in competition programming.
    """
    finder = ModuleFinder(excludes=EXCLUDE_MODULES)
    finder.run_script(str(source))

    result: List[str] = []
    bundled: Set[str] = set()
    for name, module in finder.modules.items():
        file: Optional[str] = module.__file__  # type: ignore
        is_package = module.__path__ is not None  # type: ignore
        top_package = name.split(".")[0]

        if file is None:
            # built-in module
            continue

        if top_package in expand_module:
            if not file.endswith(".py"):
                logger.error("Cannot bundle extention module.")
                sys.exit(1)

            bundled.add(top_package)
            logger.info(f"Load `{name}` from {file}")
            if not result:
                result.append(BUNDLE_IMPORTER_CODE)

            module_code = Path(file).read_text()
            module_code = module_code.replace("\\", "\\\\")
            module_code = module_code.replace('"""', '\\"""')
            result.append(
                "BundleImporter.add_module(\n"
                f'    fullname="{name}",\n'
                f"    is_package={is_package},\n"
                '    code="""\\\n'
                f'{module_code}""",\n'
                ")\n"
            )

    if result:
        result.append("sys.meta_path.append(BundleImporter)\n\n")

    code = source.read_text()
    insert_point = search_insert_point(code)
    code_lines = code.splitlines(keepends=True)
    if insert_point == 0:
        code_lines.insert(insert_point, "\n".join(result))
    else:
        code_lines.insert(insert_point, "\n" + "\n".join(result))

    infomations: List[str] = []
    for top_package in sorted(list(bundled)):
        info = make_metadata(top_package)
        if info is not None:
            if not infomations:
                infomations.append("\n\n# package infomations\n")
                infomations.append("# " + "-" * 77 + "\n")
            infomations.append(info)
            infomations.append("# " + "-" * 77 + "\n")

    return "".join(code_lines + infomations)
